<div class="content">
    <h1>memflow - machine introspection framework</h1>

    <div class="badges" fxLayout="row" fxLayoutAlign="start stretch" fxLayoutGap="0.5em">
        <a href="https://crates.io/crates/memflow">
            <img alt="Crates.io" src="https://img.shields.io/crates/v/memflow.svg">
        </a>
        <a href="https://github.com/memflow/memflow/actions">
            <img alt="Build and test"
                src="https://github.com/memflow/memflow/workflows/Build%20and%20test/badge.svg?branch=master">
        </a>
        <a href="https://codecov.io/gh/memflow/memflow">
            <img alt="Codecov"
                src="https://codecov.io/gh/memflow/memflow/branch/master/graph/badge.svg?token=XT7R158N6W">
        </a>
        <a href="https://github.com/memflow/memflow/blob/master/LICENSE">
            <img alt="MIT licensed" src="https://img.shields.io/badge/license-MIT-blue.svg">
        </a>
        <a href="https://discord.gg/afsEtMR">
            <img alt="Discord" src="https://img.shields.io/discord/738739624976973835?color=%20%237289da&label=Discord">
        </a>
    </div>

    <div class="text">
        <p>
            memflow is a library that allows live memory introspection of running systems and their snapshots.
            Due to its modular approach it trivial to support almost any scenario where Direct Memory Access is
            available.
        </p>
        <p>
            The very core of the library is a
            <a href="https://docs.rs/memflow/latest/memflow/mem/phys_mem/trait.PhysicalMemory.html">PhysicalMemory</a>
            that
            provides direct memory access in an abstract environment.
            This object that can be defined both statically, and dynamically with the use of the `inventory` feature.
            If `inventory` is enabled, it is possible to dynamically load libraries that provide Direct Memory Access.
        </p>
        <p>
            Through the use of OS abstraction layers, like <a
                href="https://github.com/memflow/memflow/tree/master/memflow-win32">memflow-win32</a>,
            user can gain access to virtual memory of individual processes, by creating objects that implement
            <a href="https://docs.rs/memflow/latest/memflow/mem/virt_mem/trait.VirtualMemory.html">VirtualMemory</a>.
        </p>
        <p>
            Bridging the two is done by a highly throughput optimized virtual address translation function, which allows
            for crazy fast memory transfers at scale.
        </p>
        <p>
            The core is architecture independent (as long as addresses fit in 64-bits), and currently both 32, and
            64-bit versions of the x86 family are available to be used.
        </p>
        <p> For non-rust libraries, it is possible to use the <a
                href="https://github.com/memflow/memflow/tree/master/memflow-ffi">FFI</a> to interface with the library.
        </p>
    </div>
</div>