<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>memflow project</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
	<link rel="stylesheet" href="../../styles.css"></head>
</head>
<body>
    <div class="root">
        <div class="pre-logo">
        <pre class="logo">
                             ______             
   ____ ___  ___  ____ ___  / __/ /___ _      __
  / __ `__ \/ _ \/ __ `__ \/ /_/ / __ \ | /| / /
 / / / / / /  __/ / / / / / __/ / /_/ / |/ |/ / 
/_/ /_/ /_/\___/_/ /_/ /_/_/ /_/\____/|__/|__/</pre>
            <ul class="navbar">
                
				<a href="../..//">Home</a>
                <pre> | </pre>
                
                
				<a href="../../blog/">Blog</a>
                <pre> | </pre>
                
                
				<a href="../../about/">About</a>
                <pre> | </pre>
                
                
				<a href="../../quick_start/">Quick start guide</a>
                <pre> | </pre>
                
                
				<a href="../../docs/">Documentation</a>
                
            </ul> 
        </div>

        <div class="pre-content">
            <div class="content">
                <h1>Announcing memflow 0.2.0</h1>
<p>Today, we are proud to release the first stable version of memflow 0.2! 3 years in the making, this
is certainly a monumental release. In this post, we will go through the key changes to the fastest
and most flexible physical memory introspection and forensics framework to date.</p>
<h2>Key changes</h2>
<h3>0. <a href="https://github.com/memflow/memflowup">memflowup</a></h3>
<p>Not a library change, but the ecosystem change! We now have a rust-written memflowup utility that
makes it much easier to manage your memflow installation. Key features:</p>
<ul>
<li>Download binary builds (optional).</li>
<li>Split between stable and dev versions.</li>
<li>Custom install scripts, for more complicated plugins<ul>
<li>Used by <a href="https://github.com/memflow/memflow-kvm"><code>memflow-kvm</code></a> for DKMS install.</li>
<li>Entry point for these is <code>install.rhai</code> script at the root of the package's repo.</li>
</ul>
</li>
</ul>
<p>You can get started with memflowup by running the following:</p>
<div class="highlight"><pre><span></span>&gt; curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.memflow.io | sh
</pre></div>
<h3>1. OS layers and modularity</h3>
<p>With the advent of 0.2 series, we now abstracted most of <code>memflow-win32</code> functionality behind
shared set of traits. These traits allow the user to interact with the operating system in unified
manner. In addition, we now made OS a plugin, just as Connectors were in 0.1! And finally, we do
indeed have multiple OS backends available, right now:</p>
<ul>
<li><a href="https://github.com/memflow/memflow-win32"><code>memflow-win32</code></a>, for Windows analysis, given physical
memory access.</li>
<li><a href="https://github.com/memflow/memflow-native"><code>memflow-native</code></a>, for syscall based interaction with
the running operating system.</li>
<li>WIP: <code>memflow-linux</code><ul>
<li>Don't expect much anytime soon, because the challenge of cross-version, zero-knowledge linux
support is a tricky one.</li>
</ul>
</li>
</ul>
<p>With this, OS-independent code that works with <code>memflow-win32</code>, should also work on local OS. Here's
an example of such code:</p>
<div class="highlight"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">memflow</span>::<span class="n">prelude</span>::<span class="n">v1</span>::<span class="o">*</span><span class="p">;</span>

<span class="c1">// We don&#39;t care what type of process we get, so long as it&#39;s a process</span>
<span class="k">fn</span> <span class="nf">module_address</span><span class="p">(</span><span class="n">process</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Process</span><span class="p">,</span><span class="w"> </span><span class="n">module</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">process</span><span class="p">.</span><span class="n">module_by_name</span><span class="p">(</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">base</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>In addition, modularization of operating systems allows for greater portability of connectors. For
instance, we have now split <code>memflow-qemu-procfs</code> into
<a href="https://github.com/memflow/memflow-qemu"><code>memflow-qemu</code></a>, which (optionally) accepts an OS layer.
This way, you can not only analyze QEMU VMs running on your computer, but you can also open them up
in a nested way on a machine that is already being analyzed through DMA. As seen in this chart:</p>
<div class="asciirend" id="asciirend-0"><pre>                        *%%*%%%%                                        
                   %%%%%%%%%%%*%%%%%%                                   
                %%%%%.............%%=-=                                 
                %%%%%.memflow-kvm.=--=-                                 
                %%*%%.............---==                                 
                 %%%%%*%%***=-=-======-                                 
                     %%*%%%%====-=                                      
                          %%- =                                         
                              %+%%%%                                    
                         %*%%%%+%%%%%%%%%                               
                      %%%%...............%%=                            
                      %%%%.memflow-win32.-=-                            
                      %%%*...............-==                            
                      %%%%%*%%%*%--------=-=                            
                          %%%%*%%----===                                
                               %*=-=                                    
                                    +%%*%                               
                                *%%*+%%%%%%%%%                          
                            %%%%*%%%%%**%%%%%*%%%=                      
                            %%%..............=----                      
                            %%%.memflow-qemu.===--                      
                            %%*..............=-===                      
                               %%**%%*%=-=-==--                         
                                    %%*-==                              
                                         = %*%                          
                                      **%%=%%%%%%%%                     
                                 %%%%%%%%%*%%%%*%%%%%%*                 
                                 **%%...............=-==                
                                 %%%%.memflow-win32.--==                
                                 %%%%...............=---                
                                   %%%%%%%%%-=-==--=-                   
                                        %%%%--=-                        
</pre></div><h3>2. Stable ABI</h3>
<p>In 0.1, the Connectors were turned into plugins through use of Rust trait objects. This was an okay
solution at the time, however, we knew that it was not a safe one - changes in Rust versions could
change the layout of those trait objects, leading to crashes or other misbehavior, in case of
mismatch of plugin's <code>rustc</code> version and the one of the user's code. While the layout has remained
stable most of the time, the tides started to shift a few years ago, as more effort was put into
trait objects on the compiler front.</p>
<p>For 0.2, we knew we could not keep the status quo, so, we built <code>cglue</code>. The crate allows for
simple and flexible ABI safe code generation, suited for the needs of <code>memflow</code>. Throughout the
(very long) beta period, we received 0 crash reports stemming from ABI instability, while 0.1 had
such cases. Therefore, we can conclude that it was a good investment that already made memflow more
stable.</p>
<p>In <code>0.2.0-betaX</code> series, you may have encountered &quot;invalid ABI&quot; errors, well, fear not, because in
stable series, we commit to not breaking the ABI across entirety of <code>0.2</code> series, so this problem
should be a thing of the past for most users.</p>
<h3>3. Memory constrained vtop</h3>
<p>memflow 0.2 introduces the most scalable virtual address translation backend, period. The backend
is able to walk entire page tree in milliseconds, targeting any modern memory architecture (x86 and
ARM support out-of-the box, sufficient building blocks for RISC-V). In addition, compared to 0.1,
the new backend uses fixed-size buffers, meaning RAM usage will no longer blow up on large
translation ranges.</p>
<h3>4. 64-bit and 128-bit address spaces, on all architectures</h3>
<p>We now support analyzing 64-bit operating systems on 32-bit machines. In addition, if there was a
theoretical 128-bit architecture, we would support that as well. However, it's more of a PoC and we
do not expect this to be needed in the foreseeable future.</p>
<p>The support can be toggled through <code>64_bit_mem</code> (default) and <code>128_bit_mem</code> features. Do note that
these feature toggles do change memflow's ABI and it should not be possible to mix the plugin
features.</p>
<h3>5. Shared <code>MemoryView</code></h3>
<p>In 0.1, we have had a split between physical and virtual memory. The reason for the split is
caching - we wish minimize latency by caching read-only memory in high-latency scenarios.
However, to tell the cache what mode the memory is in (readable/writeable/executable), you must add
metadata with each request. Meanwhile, this metadata may only be filled in by the virtual address
translation backend.</p>
<p>If user submits an I/O operation - they can't possibly know whether the request is going to a
read-only, or a writeable page, therefore they just submit <code>UNKNOWN</code> page flags. This is
complicated, therefore, we have lowered the gap between virtual and physical memory access through
use of <code>MemoryView</code> trait. This trait not only removes the need for the user to explicitly submit
the page flags, but also brings all I/O helpers that existed in virtual memory contexts. To use
<code>MemoryView</code> on physical memory, just use the <code>phys_view</code> function:</p>
<div class="highlight"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">memflow</span>::<span class="n">prelude</span>::<span class="n">v1</span>::<span class="o">*</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">inventory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Inventory</span>::<span class="n">scan</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inventory</span><span class="p">.</span><span class="n">create_connector</span><span class="p">(</span><span class="s">&quot;dummy&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Create a physical memory view</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="n">phys_view</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Read from phys addr 0</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mf">0.</span><span class="n">into</span><span class="p">())</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></div>
<h3>6. C and C++ are now first-class citizen</h3>
<p>The FFI is now automatically generated using <code>cbindgen</code> and <code>cglue-bindgen</code>. It may initially seem
like a downgrade, however, this way we can ensure entirety of memflow's plugin-focused API surface
can be both accessed, and implemented by foreign languages, such as C and C++.</p>
<p>The key to using the new FFI, is reading Rust documentation and examples, and then finding the
function equivalents in the headers. There are a few quirks here and there, but after understanding
them, using the FFI should not be hard. For inspiration, see the following:</p>
<ul>
<li><a href="https://github.com/memflow/memflow/tree/0.2.0/memflow-ffi/examples/c">C examples</a></li>
<li><a href="https://github.com/memflow/memflow/tree/0.2.0/memflow-ffi/examples/cpp">C++ examples</a></li>
<li><a href="https://github.com/memflow/memflow-cmake-example">CMake template</a></li>
</ul>
<h2>Side projects</h2>
<p><code>memflow</code> is as useful as the projects utilizing it. To get started with the new version faster,
you may want to have a look at some of them. Here's the list of first-party releases:</p>
<ul>
<li><a href="https://github.com/memflow/reflow"><code>reflow</code></a> - execute code on top of virtual memory.</li>
<li><a href="https://github.com/memflow/scanflow"><code>scanflow</code></a> - basic CheatEngine features in a command line
interface.</li>
<li><a href="https://github.com/memflow/cloudflow"><code>cloudflow</code></a> (WIP) - flexible filesystem based way to
interact with memflow.</li>
<li><a href="https://github.com/memflow/memflow-py"><code>memflow-py</code></a> - python bindings for memflow (courtesy of
emesare).</li>
</ul>
<h2>Reflection</h2>
<p>0.2 took way longer than we originally anticipated. This is mostly due to changing living
conditions and the fact that both ko1N and I are only working on the project in hobbyist capacity.
In addition, we pushed for perfection from documentation and implementation front - a feat
infeasible at the current point. We do believe memflow is the framework that is going to bring the
most empowerement to users, however, there are still ways to go.</p>
<h2>Next up - Async Metamorphosis</h2>
<p>Next, we will work towards integrating <a href="https://github.com/memflow/mfio"><code>mfio</code></a> into memflow,
which will enable higher scalability and simplicity. The key change is going to be transition from
synchronous to asynchronous API. There are still a lot of open questions regarding this, such as
FFI handling, how much the individual pieces of memflow's code will have to change, and how
multithreading needs to be handled. However, we are confident those questions are not impossible
to solve. Once the metamorphosis is done, we can consider the structure of memflow done. What comes
afterwards, is rapid feature development. It will definitely be an exciting time to be alive. So
let's just get there, shall we?</p>
<p>- h33p</p>

<script type="module">
	import ascii_render from "../../static/js/draw.js";
        const scene_0 = '{    "camera_props": {        "proj_mode": "Orthographic",        "fov": 1.0,        "near": 0.01,        "far": 100.0    },    "camera_controller":{"fov_y":1.0,"focus_point":[0.0,0.0,0.0],"rot":[-0.19996414, -0.08282786, 0.37361234, 0.90197986],"dist":2.0,"in_motion":"None","scroll_sensitivity":0.02,"orbit_sensitivity":1.0,"last_down":false,"pressed":false},    "objects":[        {            "transform":[                1.0,0.0,0.0,0.0,                0.0,1.0,0.0,0.0,                0.0,0.0,1.0,0.0,                0.0,0.0,0.0,1.0            ],            "material":0,            "ty":{                "Primitive":{                    "Line":{                        "start":[-0.75,0.0,1.5,1.0],                        "end":[-0.25,0.0,0.5,1.0]                    }                }            }        },        {            "transform":[                1.0,0.0,0.0,0.0,                0.0,1.0,0.0,0.0,                0.0,0.0,1.0,0.0,                0.0,0.0,0.0,1.0            ],            "material":0,            "ty":{                "Primitive":{                    "Line":{                        "start":[-0.25,0.0,0.5,1.0],                        "end":[0.25,0.0,-0.5,1.0]                    }                }            }        },        {            "transform":[                1.0,0.0,0.0,0.0,                0.0,1.0,0.0,0.0,                0.0,0.0,1.0,0.0,                0.0,0.0,0.0,1.0            ],            "material":0,            "ty":{                "Primitive":{                    "Line":{                        "start":[0.25,0.0,-0.5,1.0],                        "end":[0.75,0.0,-1.5,1.0]                    }                }            }        },        {            "transform":[                1.0,0.0,0.0,0.0,                0.0,1.0,0.0,0.0,                0.0,0.0,1.0,0.0,                -0.75,0.0,1.5,1.0            ],"material":1,"ty":{"Cube":{"size":[1.0,1.0,0.5]}},"text":"memflow-kvm"        },        {            "transform":[                1.0,0.0,0.0,0.0,                0.0,1.0,0.0,0.0,                0.0,0.0,1.0,0.0,                -0.25,0.0,0.5,1.0            ],"material":1,"ty":{"Cube":{"size":[1.0,1.0,0.5]}},"text":"memflow-win32"        },        {            "transform":[                1.0,0.0,0.0,0.0,                0.0,1.0,0.0,0.0,                0.0,0.0,1.0,0.0,                0.25,0.0,-0.5,1.0            ],"material":1,"ty":{"Cube":{"size":[1.0,1.0,0.5]}},"text":"memflow-qemu"        },        {            "transform":[                1.0,0.0,0.0,0.0,                0.0,1.0,0.0,0.0,                0.0,0.0,1.0,0.0,                0.75,0.0,-1.5,1.0            ],"material":1,"ty":{"Cube":{"size":[1.0,1.0,0.5]}},"text":"memflow-win32"        }    ],    "bg":{"color":[0.0,0.0,0.0]},    "dithering":{"count_frames":false,"frame_cnt":4181}}';
ascii_render("asciirend-0", scene_0, null, 32, true, 4.5, 0.1, 100.0, true, true);

</script>
        
            </div>
        </div>
    </div>
</body>
</html>
